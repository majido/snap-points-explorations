<html>

	<head>
		<title>Scroll Snap-points demo</title>
		<style type="text/css">
			#scroll_container {
				height: 500px;
				overflow-y: scroll;
			}
			.item {
				box-sizing:border-box;
				width: 500px;
				height: 100%;
				border: solid;
				background-color: eee;
				text-align: center;
				vertical-align: center;
				font-size: 10em;
			}
		</style>
		<script src="bower_components/regression-js/src/regression.js" > </script>
		<script src="bower_components/bezier-easing/bezier-easing.js" > </script>

		<script src="velocity_calculator.js" > </script>

	</head>

	<body>
		<h1>Emulating Snap points implementation using onScroll events</h1>

		<div id="scroll_container">
			<div class="item">1</div>
			<div class="item">2</div>
			<div class="item">3</div>
			<div class="item">4</div>
			<div class="item">5</div>
		</div>


	</body>

	<script>
	(function(){
		"use strict";

		var scrollContainer = document.querySelector('#scroll_container');
		var velocityCalculator = new VelocityCalculator(100);

		// TODO: consult with tdresser to ensure if this has any real effect
		document.addEventListener('scroll', function() {
      		// Make 100% sure chrome knows we have a scroll listener.
    	});

		scrollContainer.addEventListener('scroll', scrollHandler);
		scrollContainer.addEventListener('touchbegin', touchstartHandler);
		scrollContainer.addEventListener('touchmove', touchmoveHandler);
		for (var event of ['touchend','mouseup'])	{
			scrollContainer.addEventListener(event, touchendHandler);
		}


		function printEvent(event) {
			console.log('event %s. scrollTop: %d.', event.type, scrollContainer.scrollTop);
		}

		
		var isScrolling = false;
		
		function scrollHandler(event) {
			isScrolling = true;
			printEvent(event);

			velocityCalculator.addValue(getPosition(), getTime());
		}

		function touchstartHandler(event) {
			//reset event buffer for direction/velocity calculation
			printEvent(event);

			velocityCalculator.reset();
			velocityCalculator.addValue(getPosition(), getTime());
		}

		function touchmoveHandler(event) {
			printEvent(event);

			velocityCalculator.addValue(getPosition(), getTime());
		}


		function touchendHandler(event){
			//handle first touchend after scrolling is complete
			if (!isScrolling) return;
			isScrolling = false;


			printEvent(event);
			//implement the custom snap logic

			//determine final destination ignoring the fling.
			//requires knowing the direction of the scroll.

			//snap to closest value
			var currentY = scrollContainer.scrollTop;
			var direction = velocityCalculator.getDirection();
			console.log("Direction: %d", direction);

			var destinationY = calculateSnapPoint(currentY, direction);

			console.log('Snap destination %d is %d pixel further.', destinationY, destinationY - currentY);

			//snap by setting scrollTop
			//var easing = window.BezierEasing.css['ease-out'];
			var easing = window.BezierEasing(0.215, 0.61, 0.355, 1); //easeOutCubic
			setupSnapAnimation(destinationY, 1000, easing);

		}


		function calculateSnapPoint(landingY, direction) {
			var interval = 500; //500 px
			var max = scrollContainer.scrollHeight;

			var closest;
			if (direction >= 0) {
				closest = Math.ceil(landingY / interval) * interval;
				closest = Math.min(closest, max);
			} else {
				closest = Math.floor(landingY / interval) * interval;
			}

			return closest;
		}
	
		/**
		* duration in ms.
		*/
		function setupSnapAnimation(destinationY, duration, easing){
			console.groupCollapsed('snap animation');
			console.log('animate to scrolltop: %d', destinationY);

			easing = easing || function(t){return t;};//default to linear easing

			var startTime = getTime(),
				endTime = startTime + duration;

			var startY = scrollContainer.scrollTop; // current location
			var expected = scrollContainer.scrollTop;

			//RAF loop

			window.requestAnimationFrame(animateSnap);

			function animateSnap(hiResTime) {

				var now = getTime();
				now = Math.min(now, endTime); // ensures the last frame is always executed
				
				var currentY = scrollContainer.scrollTop; //used only for debug purposes

				//linear movement
				var animTime = (now - startTime) / duration; // time is the time between 0 to 1

				var step = (destinationY - startY) * easing(animTime);	//apply easing by modifying animation timing using animFrame

				var newY = Math.floor(startY + step);

				console.log('diff: %d, scrollTop: %d, newY: %d, frame: %0.2f', (expected - currentY), currentY, newY, animTime);

				scrollContainer.scrollTop = expected = newY;	//FIXME: this is being overridden by scroller. Find a more appropriate way to do this

				if (now < endTime) {
					window.requestAnimationFrame(animateSnap);
				} else { //reached the end of the animation
					console.groupEnd('snap animations');
					console.log('Current scrollTop at %d', scrollContainer.scrollTop); 
					return;
				}
			}

		}
	
		var getPosition = function(){
			return scrollContainer.scrollTop;
		};

		var getTime = Date.now || function() { return new Date().getTime(); };
	}());

	</script>
</html>